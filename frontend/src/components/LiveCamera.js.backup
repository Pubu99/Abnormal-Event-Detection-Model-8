import React, { useState, useRef, useEffect } from "react";

function LiveCamera({ onDetection }) {
  const [isStreaming, setIsStreaming] = useState(false);
  const [cameraActive, setCameraActive] = useState(false);
  const [rtspUrl, setRtspUrl] = useState("");
  const [showRtspInput, setShowRtspInput] = useState(false);
  const [currentResult, setCurrentResult] = useState(null);
  const [fps, setFps] = useState(0);
  const [statusMessage, setStatusMessage] = useState("");

  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const streamRef = useRef(null);
  const wsRef = useRef(null);
  const intervalRef = useRef(null);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      stopCamera();
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  const startWebcam = async () => {
    try {
      setStatusMessage("Requesting camera access...");
      console.log("üé• Requesting camera access...");
      console.log("üé• Video ref current:", videoRef.current);

      // Simpler constraints that work more reliably
      const constraints = {
        video: true,
        audio: false,
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      console.log("‚úÖ Camera access granted!");
      console.log("Stream:", stream);
      console.log("Video tracks:", stream.getVideoTracks());

      const videoTrack = stream.getVideoTracks()[0];
      if (videoTrack) {
        console.log("Track settings:", videoTrack.getSettings());
        console.log("Track state:", videoTrack.readyState);
        console.log("Track enabled:", videoTrack.enabled);
      }

      setStatusMessage("Camera access granted, setting up video...");

      if (!videoRef.current) {
        console.error("‚ùå Video element ref is null!");
        setStatusMessage("Error: Video element not available");
        return;
      }

      console.log("üì∫ Video element found, setting srcObject...");

      // Set the stream
      videoRef.current.srcObject = stream;
      streamRef.current = stream;

      // Wait for metadata
      videoRef.current.onloadedmetadata = () => {
        console.log("üìπ Video metadata loaded");
        console.log(
          "Video dimensions:",
          videoRef.current.videoWidth,
          "x",
          videoRef.current.videoHeight
        );
        console.log("Video readyState:", videoRef.current.readyState);

        // Try to play
        videoRef.current
          .play()
          .then(() => {
            console.log("‚ñ∂Ô∏è Video playing successfully!");
            setStatusMessage("");
            setCameraActive(true);
          })
          .catch((playError) => {
            console.error("‚ùå Video play() failed:", playError);
            setStatusMessage("Error: Cannot play video");
          });
      };

      videoRef.current.onerror = (e) => {
        console.error("‚ùå Video element error:", e);
        setStatusMessage("Error: Video element failed");
      };

      console.log("‚úÖ Webcam setup initiated, waiting for video to load...");
    } catch (error) {
      console.error("‚ùå Error accessing webcam:", error);
      console.error("Error name:", error.name);
      console.error("Error message:", error.message);
      setStatusMessage("Failed: " + error.message);
      alert(
        "‚ùå Could not access webcam. Please:\n" +
          "1. Allow camera permissions\n" +
          "2. Make sure no other app is using the camera\n" +
          "3. Try selecting 'OBS Virtual Camera' if using OBS\n\n" +
          `Error: ${error.message}`
      );
    }
  };

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
    setCameraActive(false);
    setIsStreaming(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
  };

  const startAnalysis = () => {
    if (!cameraActive) {
      alert("Please connect webcam first!");
      return;
    }

    setIsStreaming(true);

    // Connect to WebSocket
    const ws = new WebSocket("ws://localhost:8000/ws/stream");
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("‚úÖ WebSocket connected");

      // Start sending frames
      intervalRef.current = setInterval(() => {
        captureAndSendFrame();
      }, 100); // Send frame every 100ms (~10 FPS)
    };

    ws.onmessage = (event) => {
      try {
        const result = JSON.parse(event.data);
        setCurrentResult(result);
        if (onDetection) {
          onDetection(result);
        }

        // Update FPS
        if (result.processing_time) {
          setFps(Math.round(1000 / result.processing_time));
        }
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
      }
    };

    ws.onerror = (error) => {
      console.error("WebSocket error:", error);
      alert(
        "‚ùå Connection error. Make sure backend is running on http://localhost:8000"
      );
      stopAnalysis();
    };

    ws.onclose = () => {
      console.log("WebSocket closed");
      stopAnalysis();
    };
  };

  const stopAnalysis = () => {
    setIsStreaming(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    if (wsRef.current) {
      wsRef.current.close();
    }
  };

  const captureAndSendFrame = () => {
    if (!videoRef.current || !canvasRef.current || !wsRef.current) return;

    const video = videoRef.current;
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");

    // Set canvas size to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Draw current video frame to canvas
    context.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Convert canvas to base64 JPEG
    canvas.toBlob(
      (blob) => {
        if (
          blob &&
          wsRef.current &&
          wsRef.current.readyState === WebSocket.OPEN
        ) {
          const reader = new FileReader();
          reader.onloadend = () => {
            const base64data = reader.result.split(",")[1];
            wsRef.current.send(base64data);
          };
          reader.readAsDataURL(blob);
        }
      },
      "image/jpeg",
      0.8
    );
  };

  const handleRtspConnect = () => {
    if (!rtspUrl.trim()) {
      alert("Please enter an RTSP URL");
      return;
    }

    // RTSP would require backend processing
    alert(
      "RTSP streaming requires backend video processing.\n" +
        `URL: ${rtspUrl}\n\n` +
        "This feature would:\n" +
        "1. Send RTSP URL to backend\n" +
        "2. Backend reads RTSP stream with OpenCV\n" +
        "3. Sends frames via WebSocket\n\n" +
        "For now, use Webcam + OBS Virtual Camera to stream video files!"
    );
  };

  return (
    <div className="space-y-6">
      {/* Video Preview */}
      <div className="bg-gray-700 rounded-xl p-6">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-bold text-white">
            {cameraActive ? "üìπ Camera Active" : "üì∑ Camera Preview"}
          </h3>
          {statusMessage && (
            <span className="text-yellow-400 text-sm">{statusMessage}</span>
          )}
          {isStreaming && (
            <div className="flex items-center space-x-4">
              <span className="text-green-400 text-sm font-semibold flex items-center">
                <span className="w-2 h-2 bg-green-400 rounded-full animate-pulse mr-2"></span>
                Live ‚Ä¢ {fps} FPS
              </span>
            </div>
          )}
        </div>

        {/* Video Element */}
        <div
          className="relative bg-black rounded-lg overflow-hidden"
          style={{ minHeight: "400px", aspectRatio: "16/9" }}
        >
          {/* Always render video element, just hide it when not active */}
          <video
            ref={videoRef}
            autoPlay
            playsInline
            muted
            style={{
              width: "100%",
              height: "100%",
              display: cameraActive ? "block" : "none",
            }}
            className="object-contain"
            onLoadedMetadata={() => console.log("Video metadata loaded")}
            onPlay={() => console.log("Video playing")}
          />
          <canvas ref={canvasRef} style={{ display: "none" }} />

          {/* Show placeholder when camera not active */}
          {!cameraActive && (
            <div className="w-full h-full flex items-center justify-center text-gray-500">
              <div className="text-center">
                <svg
                  className="w-24 h-24 mx-auto mb-4 opacity-50"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z" />
                </svg>
                <p className="text-lg">No camera connected</p>
                <p className="text-sm mt-2">
                  Connect webcam or RTSP stream below
                </p>
              </div>
            </div>
          )}

          {/* Live Indicator */}
          {cameraActive && isStreaming && (
            <div className="absolute top-4 left-4 bg-red-600 text-white px-3 py-1 rounded-full text-sm font-semibold flex items-center">
              <span className="w-2 h-2 bg-white rounded-full animate-pulse mr-2"></span>
              ANALYZING
            </div>
          )}

          {/* Current Result Overlay */}
          {cameraActive && currentResult && (
            <div className="absolute bottom-4 left-4 right-4 bg-black bg-opacity-75 text-white p-4 rounded-lg">
              <div className="flex justify-between items-center">
                <div>
                  <p className="text-sm text-gray-400">Detected Class</p>
                  <p className="text-lg font-bold">
                    {currentResult.predicted_class || "Processing..."}
                  </p>
                </div>
                <div className="text-right">
                  <p className="text-sm text-gray-400">Confidence</p>
                  <p className="text-2xl font-bold text-green-400">
                    {currentResult.confidence
                      ? `${(currentResult.confidence * 100).toFixed(1)}%`
                      : "..."}
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Control Buttons */}
        <div className="mt-4 flex space-x-3">
          {!cameraActive ? (
            <button
              onClick={startWebcam}
              className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 rounded-lg transition-colors"
            >
              üìπ Connect Webcam
            </button>
          ) : (
            <>
              {!isStreaming ? (
                <button
                  onClick={startAnalysis}
                  className="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-3 rounded-lg transition-colors"
                >
                  ‚ñ∂Ô∏è Start Analysis
                </button>
              ) : (
                <button
                  onClick={stopAnalysis}
                  className="flex-1 bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-3 rounded-lg transition-colors"
                >
                  ‚è∏Ô∏è Pause Analysis
                </button>
              )}
              <button
                onClick={stopCamera}
                className="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
              >
                ‚èπÔ∏è Stop Camera
              </button>
            </>
          )}
        </div>
      </div>

      {/* RTSP Stream Option */}
      <div className="bg-gray-700 rounded-lg p-6">
        <div className="flex items-center justify-between mb-4">
          <h4 className="text-white font-semibold flex items-center">
            <svg
              className="w-5 h-5 mr-2"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fillRule="evenodd"
                d="M2 5a2 2 0 012-2h12a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2V5zm3.293 1.293a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 01-1.414-1.414L7.586 10 5.293 7.707a1 1 0 010-1.414zM11 12a1 1 0 100 2h3a1 1 0 100-2h-3z"
                clipRule="evenodd"
              />
            </svg>
            RTSP Stream (IP Camera)
          </h4>
          <button
            onClick={() => setShowRtspInput(!showRtspInput)}
            className="text-blue-400 hover:text-blue-300 text-sm font-semibold"
          >
            {showRtspInput ? "Hide" : "Show"}
          </button>
        </div>

        {showRtspInput && (
          <div className="space-y-3">
            <input
              type="text"
              value={rtspUrl}
              onChange={(e) => setRtspUrl(e.target.value)}
              placeholder="rtsp://username:password@ip:port/stream"
              className="w-full bg-gray-800 text-white px-4 py-2 rounded border border-gray-600 focus:border-purple-500 focus:outline-none"
            />
            <button
              onClick={handleRtspConnect}
              className="w-full bg-purple-600 hover:bg-purple-700 text-white py-2 rounded transition-colors font-semibold"
            >
              Connect RTSP Stream
            </button>
            <p className="text-gray-400 text-xs">
              üí° Tip: Use OBS Virtual Camera to stream video files as webcam
              input for testing!
            </p>
          </div>
        )}
      </div>

      {/* Info */}
      <div className="bg-orange-900 bg-opacity-30 border border-orange-500 rounded-lg p-4">
        <h3 className="text-orange-300 font-semibold mb-2 flex items-center">
          <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path
              fillRule="evenodd"
              d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
              clipRule="evenodd"
            />
          </svg>
          Live Detection Features
        </h3>
        <ul className="text-gray-300 text-sm space-y-1">
          <li>‚úì Real-time anomaly detection (30+ FPS)</li>
          <li>‚úì Instant alerts for dangerous objects</li>
          <li>‚úì Multi-camera synchronization support</li>
          <li>‚úì Recording and playback capabilities</li>
        </ul>
      </div>
    </div>
  );
}

export default LiveCamera;
